## メモ

基本方針は、除数の2の補数表現をとって加算するという方式である。

加算は、純粋な桁上げ伝搬32bit加算器を用いている。
2の補数計算はもっと簡単な方法があった気もするが思い出せなかったので同じ加算器を用いている。
はじめは、4bit桁上げ先見加算器 × 8みたいな形にし、最下部の加算器に桁上げ1を与えることで計算量を抑えれないかと思ったが、演算子の縛りをかいくぐりながら加算の繰り返しの終了判定をするのがめんどくさそうだったのでこうした。
終了判定をどうするか悩んだ結果、`while(carry)`としている。

問題文的にオーバフローは考慮しなくてよさそうだったが、せっかくなので考慮に入れた。
判定条件は、

1. 加数、被加数が共に正だが、計算結果が負
2. 加数、被加数が共に負だが、計算結果が正

TestCaseのうち、負の最大値を引く場合に対処できていないのが難点、2の補数をとる時点でOVERFLOWしてしまうので是非もないかもしれないが実際のところはどうなのだろう。
