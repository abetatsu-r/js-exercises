## 解答

### i1

- 予想: 継続実行される(1回目と2回目でlogの結果が変わる)
- 結果: 42, 100の順で出力される
- 理由: `Promise.any`のうち最も早く完了するのは、`wait1`のため、最初に満たされた値42がvに格納される。だが、二つ目のPromiseがまだ生きている(すでにcallbackが保存されているから？)ため、`v=100`の処理が履行され、結果として二度目の`log`では100が表示される。

### i2

- 予想: C,B,Aの順で出力され、[A, B, C]を得る
- 結果: 的中
- 理由: `Promise.All`は要素Promise全ての完了まで満たされないため、C,B,Aの順で出力される。また、`Promise.All`を満たす値は完了順に依存せず、渡された順番での配列になるため`[A, B, C]`を得る。

### i3

- 予想: y,42,B,0の順で出力される
- 結果: 的中
- 理由: `Promise.All`自体は即座に失敗するが、`Promise.Any`同様、他のPromiseは続行しようとするため。

### i4, i5, i6

- 予想:
  - i4 ⇒ 1秒おきに0,1,2,3,4が出力される
  - i5 ⇒ 一瞬で0,1,2,3,4が出力される
  - i6 ⇒ 1秒おきに4,3,2,1,0が出力される
- 結果:
  - i4 ⇒ 5,4,3,2,1秒ごとに出力される
  - i5 ⇒ 一瞬でCOMPLETEDしたのち、一秒ごとに4,3,2,1の順で出力される
  - i6 ⇒ 的中
- 理由:
  - i5について`then()`のcallbackに関数以外を指定した場合、その値はすぐさま評価され、無視して前の解決した値を使って、次の処理に移ることによるもの。そのため、1秒待つ間もなく`for`ループが完走し、評価中の`wait(5-1)`の実行結果が反映されることになるので、このような結果になる。
  - i6について、`Promise.All`は要素のPromiseをほぼ同時に実行し、そのすべての完了を待つものであるからにしてカウントダウンされるような形式で出力される。

### i7, i8

- 予想:
  - i7 ⇒ 10が出力される
  - i8 ⇒ 5が出力される
- 結果:
  - i7 ⇒ 的中
  -
- 理由:
  - i7について、`Promise.All`中の処理がすべてvに影響を与えるため10になる。
  - i8について、`await()`の前後でvの値が変わっても、すでに代入が完了しているnextの値は変わらないため
