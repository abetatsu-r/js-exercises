## 解答

### f3: then のコールバック内の例外は try/catch でキャッチできるだろうか

- 予想: できない
- 結果: できない
- 理由: wait()が返ってくる前に、finally処理が完結するため

```
wait
|----------------|
                  logA
                  |----|
                        errX
                        |---|
  logC
  |---|
```

### f4:

予想: A,B,100の順で出力される

結果: A,B,100の順で出力される

理由: wait2の後にwaitが満たされ、その戻り値の100が最後のthenに渡され、即座に満たされ出力されるため

### f5:

予想: undefinedが最後に出力される  
結果: B, A, 40の順で出力される  
理由: 引数として渡されたPromiseがthen()呼び出しのタイミングで実行され、代わりに前のPromiseの値を伝播させる単純関数に置換されるため。

### f6: 1つの Promise に対し then を2回呼び出すとどうなるか

予想: A,B,Cの順で出力される  
解答: A,B,Cの順で出力される  
理由: B,Cはともにプロミスpが解決されたときに実行されるコールバック関数として存在する。そのため、まずpが満たされ(Aが表示され)、次にwait1,wait2がほぼ同時に起動する。wait2の方が待ち時間が長いため先にwait1のpromiseがみたされ、Bが出力されその後Cが出力される。

### f7: 解決済みの Promise の then を呼び出すとどうなるか

予想:Aがでて1秒後にB,続けざまにCが出る  
結果:予想の通り  
理由: wait1,wait2は同時に実行開始される。wait2が満たされたのち、callback関数が呼び出されるが、pが既に満たされているため待ち時間なくBが表示され、その後Cがすぐさま表示される。

### f8

予想: X,Aが出力される  
結果: 同上  
理由: wait1が解決後、errXが発生、発生したエラーXはpromiseチェーンを下っていき、catch()を見つけ、これが実行される(= errYはスキップされる)。その後、finallyが実行されるため。

### f9

予想: Y,Aが出力される  
結果: 同上  
理由: f8と異なり、最初のthen()が満たされるのでerrYが発生する、その後はf8と同じ

### f10

予想: Aが出力されエラーになる  
結果: 同上  
理由: then(r, c)はthenの対象となるpromiseが満たされたか、失敗したかによってr, cのどちらを実行するか決めるモノである。今回、1つめのthenは成功するため、errYのみが実行され、その後finallyが実行される。catchが実行されないためerrYはそのままエラーとして発現する。

### f11

予想: Xが出力される  
結果: 同上  
理由: promiseが失敗した判定になるため、後続のcatchが実行されるから

### f12

予想: エラーが吹っ飛んでくる  
結果: 吹っ飛んできた  
理由: あくまでpromise自体は満たされた判定になるので、catchには捕まらないから
